//! # DBus interface proxies for: `org.freedesktop.UDisks2.Manager`, `org.freedesktop.UDisks2.Drive`, `org.freedesktop.UDisks2.Drive.Ata`, `org.freedesktop.UDisks2.Block`, `org.freedesktop.UDisks2.PartitionTable`, `org.freedesktop.UDisks2.Partition`, `org.freedesktop.UDisks2.Filesystem`, `org.freedesktop.UDisks2.Swapspace`, `org.freedesktop.UDisks2.Encrypted`, `org.freedesktop.UDisks2.Loop`, `org.freedesktop.UDisks2.MDRaid`, `org.freedesktop.UDisks2.Job`
//!
//! This code was generated by `zbus-xmlgen` `1.0.0` from DBus introspection data.
//! Source: `org.freedesktop.UDisks2.xml`.
//!
//! You may prefer to adapt it, instead of using it verbatim.
//!
//! More information can be found in the
//! [Writing a client proxy](https://dbus.pages.freedesktop.org/zbus/client.html)
//! section of the zbus documentation.
//!

use zbus::dbus_proxy;

// #[dbus_proxy(interface = "org.freedesktop.UDisks2.Manager")]
#[dbus_proxy(
    interface = "org.freedesktop.UDisks2.Manager",
    default_service = "org.freedesktop.UDisks2",
    default_path = "/org/freedesktop/UDisks2/Manager"
)]
trait Manager {
    /// CanCheck method
    fn can_check(&self, type_: &str) -> zbus::Result<(bool, String)>;

    /// CanFormat method
    fn can_format(&self, type_: &str) -> zbus::Result<(bool, String)>;

    /// CanRepair method
    fn can_repair(&self, type_: &str) -> zbus::Result<(bool, String)>;

    /// CanResize method
    fn can_resize(&self, type_: &str) -> zbus::Result<(bool, u64, String)>;

    /// EnableModule method
    fn enable_module(&self, name: &str, enable: bool) -> zbus::Result<()>;

    /// EnableModules method
    fn enable_modules(&self, enable: bool) -> zbus::Result<()>;

    /// GetBlockDevices method
    fn get_block_devices(
        &self,
        options: std::collections::HashMap<&str, zvariant::Value<'_>>,
    ) -> zbus::Result<Vec<zvariant::OwnedObjectPath>>;

    /// LoopSetup method
    fn loop_setup(
        &self,
        //fd: std::os::unix::io::RawFd,
        fd: zvariant::Fd,
        options: std::collections::HashMap<&str, zvariant::Value<'_>>,
    ) -> zbus::Result<zvariant::OwnedObjectPath>;

    /// MDRaidCreate method
    fn mdraid_create(
        &self,
        blocks: &[zvariant::ObjectPath<'_>],
        level: &str,
        name: &str,
        chunk: u64,
        options: std::collections::HashMap<&str, zvariant::Value<'_>>,
    ) -> zbus::Result<zvariant::OwnedObjectPath>;

    /// ResolveDevice method
    fn resolve_device(
        &self,
        devspec: std::collections::HashMap<&str, zvariant::Value<'_>>,
        options: std::collections::HashMap<&str, zvariant::Value<'_>>,
    ) -> zbus::Result<Vec<zvariant::OwnedObjectPath>>;

    /// DefaultEncryptionType property
    #[dbus_proxy(property)]
    fn default_encryption_type(&self) -> zbus::Result<String>;

    /// SupportedEncryptionTypes property
    #[dbus_proxy(property)]
    fn supported_encryption_types(&self) -> zbus::Result<Vec<String>>;

    /// SupportedFilesystems property
    #[dbus_proxy(property)]
    fn supported_filesystems(&self) -> zbus::Result<Vec<String>>;

    /// Version property
    #[dbus_proxy(property)]
    fn version(&self) -> zbus::Result<String>;
}

#[dbus_proxy(
    interface = "org.freedesktop.UDisks2.Drive",
    default_service = "org.freedesktop.UDisks2"
)]
trait Drive {
    /// Eject method
    fn eject(
        &self,
        options: std::collections::HashMap<&str, zvariant::Value<'_>>,
    ) -> zbus::Result<()>;

    /// PowerOff method
    fn power_off(
        &self,
        options: std::collections::HashMap<&str, zvariant::Value<'_>>,
    ) -> zbus::Result<()>;

    /// SetConfiguration method
    fn set_configuration(
        &self,
        value: std::collections::HashMap<&str, zvariant::Value<'_>>,
        options: std::collections::HashMap<&str, zvariant::Value<'_>>,
    ) -> zbus::Result<()>;

    /// CanPowerOff property
    #[dbus_proxy(property)]
    fn can_power_off(&self) -> zbus::Result<bool>;

    /*
    /// Configuration property
    #[dbus_proxy(property)]
    fn configuration(
        &self,
    ) -> zbus::Result<std::collections::HashMap<String, zvariant::OwnedValue>>;
    */

    /// ConnectionBus property
    #[dbus_proxy(property)]
    fn connection_bus(&self) -> zbus::Result<String>;

    /// Ejectable property
    #[dbus_proxy(property)]
    fn ejectable(&self) -> zbus::Result<bool>;

    /// Id property
    #[dbus_proxy(property)]
    fn id(&self) -> zbus::Result<String>;

    /// Media property
    #[dbus_proxy(property)]
    fn media(&self) -> zbus::Result<String>;

    /// MediaAvailable property
    #[dbus_proxy(property)]
    fn media_available(&self) -> zbus::Result<bool>;

    /// MediaChangeDetected property
    #[dbus_proxy(property)]
    fn media_change_detected(&self) -> zbus::Result<bool>;

    /// MediaCompatibility property
    #[dbus_proxy(property)]
    fn media_compatibility(&self) -> zbus::Result<Vec<String>>;

    /// MediaRemovable property
    #[dbus_proxy(property)]
    fn media_removable(&self) -> zbus::Result<bool>;

    /// Model property
    #[dbus_proxy(property)]
    fn model(&self) -> zbus::Result<String>;

    /// Optical property
    #[dbus_proxy(property)]
    fn optical(&self) -> zbus::Result<bool>;

    /// OpticalBlank property
    #[dbus_proxy(property)]
    fn optical_blank(&self) -> zbus::Result<bool>;

    /// OpticalNumAudioTracks property
    #[dbus_proxy(property)]
    fn optical_num_audio_tracks(&self) -> zbus::Result<u32>;

    /// OpticalNumDataTracks property
    #[dbus_proxy(property)]
    fn optical_num_data_tracks(&self) -> zbus::Result<u32>;

    /// OpticalNumSessions property
    #[dbus_proxy(property)]
    fn optical_num_sessions(&self) -> zbus::Result<u32>;

    /// OpticalNumTracks property
    #[dbus_proxy(property)]
    fn optical_num_tracks(&self) -> zbus::Result<u32>;

    /// Removable property
    #[dbus_proxy(property)]
    fn removable(&self) -> zbus::Result<bool>;

    /// Revision property
    #[dbus_proxy(property)]
    fn revision(&self) -> zbus::Result<String>;

    /// RotationRate property
    #[dbus_proxy(property)]
    fn rotation_rate(&self) -> zbus::Result<i32>;

    /// Seat property
    #[dbus_proxy(property)]
    fn seat(&self) -> zbus::Result<String>;

    /// Serial property
    #[dbus_proxy(property)]
    fn serial(&self) -> zbus::Result<String>;

    /// SiblingId property
    #[dbus_proxy(property)]
    fn sibling_id(&self) -> zbus::Result<String>;

    /// Size property
    #[dbus_proxy(property)]
    fn size(&self) -> zbus::Result<u64>;

    /// SortKey property
    #[dbus_proxy(property)]
    fn sort_key(&self) -> zbus::Result<String>;

    /// TimeDetected property
    #[dbus_proxy(property)]
    fn time_detected(&self) -> zbus::Result<u64>;

    /// TimeMediaDetected property
    #[dbus_proxy(property)]
    fn time_media_detected(&self) -> zbus::Result<u64>;

    /// Vendor property
    #[dbus_proxy(property)]
    fn vendor(&self) -> zbus::Result<String>;

    /// WWN property
    #[dbus_proxy(property)]
    fn wwn(&self) -> zbus::Result<String>;
}

#[dbus_proxy(
    interface = "org.freedesktop.UDisks2.Drive.Ata",
    default_service = "org.freedesktop.UDisks2"
)]
trait Ata {
    /// PmGetState method
    fn pm_get_state(
        &self,
        options: std::collections::HashMap<&str, zvariant::Value<'_>>,
    ) -> zbus::Result<u8>;

    /// PmStandby method
    fn pm_standby(
        &self,
        options: std::collections::HashMap<&str, zvariant::Value<'_>>,
    ) -> zbus::Result<()>;

    /// PmWakeup method
    fn pm_wakeup(
        &self,
        options: std::collections::HashMap<&str, zvariant::Value<'_>>,
    ) -> zbus::Result<()>;

    /// SecurityEraseUnit method
    fn security_erase_unit(
        &self,
        options: std::collections::HashMap<&str, zvariant::Value<'_>>,
    ) -> zbus::Result<()>;

    /// SmartGetAttributes method
    fn smart_get_attributes(
        &self,
        options: std::collections::HashMap<&str, zvariant::Value<'_>>,
    ) -> zbus::Result<
        Vec<(
            u8,
            String,
            u16,
            i32,
            i32,
            i32,
            i64,
            i32,
            std::collections::HashMap<String, zvariant::OwnedValue>,
        )>,
    >;

    /// SmartSelftestAbort method
    fn smart_selftest_abort(
        &self,
        options: std::collections::HashMap<&str, zvariant::Value<'_>>,
    ) -> zbus::Result<()>;

    /// SmartSelftestStart method
    fn smart_selftest_start(
        &self,
        type_: &str,
        options: std::collections::HashMap<&str, zvariant::Value<'_>>,
    ) -> zbus::Result<()>;

    /// SmartSetEnabled method
    fn smart_set_enabled(
        &self,
        value: bool,
        options: std::collections::HashMap<&str, zvariant::Value<'_>>,
    ) -> zbus::Result<()>;

    /// SmartUpdate method
    fn smart_update(
        &self,
        options: std::collections::HashMap<&str, zvariant::Value<'_>>,
    ) -> zbus::Result<()>;

    /// AamEnabled property
    #[dbus_proxy(property)]
    fn aam_enabled(&self) -> zbus::Result<bool>;

    /// AamSupported property
    #[dbus_proxy(property)]
    fn aam_supported(&self) -> zbus::Result<bool>;

    /// AamVendorRecommendedValue property
    #[dbus_proxy(property)]
    fn aam_vendor_recommended_value(&self) -> zbus::Result<i32>;

    /// ApmEnabled property
    #[dbus_proxy(property)]
    fn apm_enabled(&self) -> zbus::Result<bool>;

    /// ApmSupported property
    #[dbus_proxy(property)]
    fn apm_supported(&self) -> zbus::Result<bool>;

    /// PmEnabled property
    #[dbus_proxy(property)]
    fn pm_enabled(&self) -> zbus::Result<bool>;

    /// PmSupported property
    #[dbus_proxy(property)]
    fn pm_supported(&self) -> zbus::Result<bool>;

    /// ReadLookaheadEnabled property
    #[dbus_proxy(property)]
    fn read_lookahead_enabled(&self) -> zbus::Result<bool>;

    /// ReadLookaheadSupported property
    #[dbus_proxy(property)]
    fn read_lookahead_supported(&self) -> zbus::Result<bool>;

    /// SecurityEnhancedEraseUnitMinutes property
    #[dbus_proxy(property)]
    fn security_enhanced_erase_unit_minutes(&self) -> zbus::Result<i32>;

    /// SecurityEraseUnitMinutes property
    #[dbus_proxy(property)]
    fn security_erase_unit_minutes(&self) -> zbus::Result<i32>;

    /// SecurityFrozen property
    #[dbus_proxy(property)]
    fn security_frozen(&self) -> zbus::Result<bool>;

    /// SmartEnabled property
    #[dbus_proxy(property)]
    fn smart_enabled(&self) -> zbus::Result<bool>;

    /// SmartFailing property
    #[dbus_proxy(property)]
    fn smart_failing(&self) -> zbus::Result<bool>;

    /// SmartNumAttributesFailedInThePast property
    #[dbus_proxy(property)]
    fn smart_num_attributes_failed_in_the_past(&self) -> zbus::Result<i32>;

    /// SmartNumAttributesFailing property
    #[dbus_proxy(property)]
    fn smart_num_attributes_failing(&self) -> zbus::Result<i32>;

    /// SmartNumBadSectors property
    #[dbus_proxy(property)]
    fn smart_num_bad_sectors(&self) -> zbus::Result<i64>;

    /// SmartPowerOnSeconds property
    #[dbus_proxy(property)]
    fn smart_power_on_seconds(&self) -> zbus::Result<u64>;

    /// SmartSelftestPercentRemaining property
    #[dbus_proxy(property)]
    fn smart_selftest_percent_remaining(&self) -> zbus::Result<i32>;

    /// SmartSelftestStatus property
    #[dbus_proxy(property)]
    fn smart_selftest_status(&self) -> zbus::Result<String>;

    /// SmartSupported property
    #[dbus_proxy(property)]
    fn smart_supported(&self) -> zbus::Result<bool>;

    /// SmartTemperature property
    #[dbus_proxy(property)]
    fn smart_temperature(&self) -> zbus::Result<f64>;

    /// SmartUpdated property
    #[dbus_proxy(property)]
    fn smart_updated(&self) -> zbus::Result<u64>;

    /// WriteCacheEnabled property
    #[dbus_proxy(property)]
    fn write_cache_enabled(&self) -> zbus::Result<bool>;

    /// WriteCacheSupported property
    #[dbus_proxy(property)]
    fn write_cache_supported(&self) -> zbus::Result<bool>;
}

#[dbus_proxy(
    interface = "org.freedesktop.UDisks2.Block",
    default_service = "org.freedesktop.UDisks2"
)]
trait Block {
    /// AddConfigurationItem method
    fn add_configuration_item(
        &self,
        item: &(&str, std::collections::HashMap<&str, zvariant::Value<'_>>),
        options: std::collections::HashMap<&str, zvariant::Value<'_>>,
    ) -> zbus::Result<()>;

    /// Format method
    fn format(
        &self,
        type_: &str,
        options: std::collections::HashMap<&str, zvariant::Value<'_>>,
    ) -> zbus::Result<()>;

    /// GetSecretConfiguration method
    fn get_secret_configuration(
        &self,
        options: std::collections::HashMap<&str, zvariant::Value<'_>>,
    ) -> zbus::Result<Vec<(String, std::collections::HashMap<String, zvariant::OwnedValue>)>>;

    /// OpenDevice method
    fn open_device(
        &self,
        mode: &str,
        options: std::collections::HashMap<&str, zvariant::Value<'_>>,
    ) -> zbus::Result<std::os::unix::io::RawFd>;

    /// OpenForBackup method
    fn open_for_backup(
        &self,
        options: std::collections::HashMap<&str, zvariant::Value<'_>>,
    ) -> zbus::Result<std::os::unix::io::RawFd>;

    /// OpenForBenchmark method
    fn open_for_benchmark(
        &self,
        options: std::collections::HashMap<&str, zvariant::Value<'_>>,
    ) -> zbus::Result<std::os::unix::io::RawFd>;

    /// OpenForRestore method
    fn open_for_restore(
        &self,
        options: std::collections::HashMap<&str, zvariant::Value<'_>>,
    ) -> zbus::Result<std::os::unix::io::RawFd>;

    /// RemoveConfigurationItem method
    fn remove_configuration_item(
        &self,
        item: &(&str, std::collections::HashMap<&str, zvariant::Value<'_>>),
        options: std::collections::HashMap<&str, zvariant::Value<'_>>,
    ) -> zbus::Result<()>;

    /// Rescan method
    fn rescan(
        &self,
        options: std::collections::HashMap<&str, zvariant::Value<'_>>,
    ) -> zbus::Result<()>;

    /// UpdateConfigurationItem method
    fn update_configuration_item(
        &self,
        old_item: &(&str, std::collections::HashMap<&str, zvariant::Value<'_>>),
        new_item: &(&str, std::collections::HashMap<&str, zvariant::Value<'_>>),
        options: std::collections::HashMap<&str, zvariant::Value<'_>>,
    ) -> zbus::Result<()>;

    /*
    /// Configuration property
    #[dbus_proxy(property)]
    fn configuration(
        &self,
    ) -> zbus::Result<
        Vec<(
            String,
            std::collections::HashMap<String, zvariant::OwnedValue>,
        )>,
    >;
    */

    /// CryptoBackingDevice property
    #[dbus_proxy(property)]
    fn crypto_backing_device(&self) -> zbus::Result<zvariant::OwnedObjectPath>;

    /// Device property
    #[dbus_proxy(property)]
    fn device(&self) -> zbus::Result<Vec<u8>>;

    /// DeviceNumber property
    #[dbus_proxy(property)]
    fn device_number(&self) -> zbus::Result<u64>;

    /// Drive property
    #[dbus_proxy(property)]
    fn drive(&self) -> zbus::Result<zvariant::OwnedObjectPath>;

    /// HintAuto property
    #[dbus_proxy(property)]
    fn hint_auto(&self) -> zbus::Result<bool>;

    /// HintIconName property
    #[dbus_proxy(property)]
    fn hint_icon_name(&self) -> zbus::Result<String>;

    /// HintIgnore property
    #[dbus_proxy(property)]
    fn hint_ignore(&self) -> zbus::Result<bool>;

    /// HintName property
    #[dbus_proxy(property)]
    fn hint_name(&self) -> zbus::Result<String>;

    /// HintPartitionable property
    #[dbus_proxy(property)]
    fn hint_partitionable(&self) -> zbus::Result<bool>;

    /// HintSymbolicIconName property
    #[dbus_proxy(property)]
    fn hint_symbolic_icon_name(&self) -> zbus::Result<String>;

    /// HintSystem property
    #[dbus_proxy(property)]
    fn hint_system(&self) -> zbus::Result<bool>;

    /// Id property
    #[dbus_proxy(property)]
    fn id(&self) -> zbus::Result<String>;

    /// IdLabel property
    #[dbus_proxy(property)]
    fn id_label(&self) -> zbus::Result<String>;

    /// IdType property
    #[dbus_proxy(property)]
    fn id_type(&self) -> zbus::Result<String>;

    /// IdUUID property
    #[dbus_proxy(property)]
    fn id_uuid(&self) -> zbus::Result<String>;

    /// IdUsage property
    #[dbus_proxy(property)]
    fn id_usage(&self) -> zbus::Result<String>;

    /// IdVersion property
    #[dbus_proxy(property)]
    fn id_version(&self) -> zbus::Result<String>;

    /// MDRaid property
    #[dbus_proxy(property)]
    fn mdraid(&self) -> zbus::Result<zvariant::OwnedObjectPath>;

    /// MDRaidMember property
    #[dbus_proxy(property)]
    fn mdraid_member(&self) -> zbus::Result<zvariant::OwnedObjectPath>;

    /// PreferredDevice property
    #[dbus_proxy(property)]
    fn preferred_device(&self) -> zbus::Result<Vec<u8>>;

    /// ReadOnly property
    #[dbus_proxy(property)]
    fn read_only(&self) -> zbus::Result<bool>;

    /// Size property
    #[dbus_proxy(property)]
    fn size(&self) -> zbus::Result<u64>;

    /// Symlinks property
    #[dbus_proxy(property)]
    fn symlinks(&self) -> zbus::Result<Vec<Vec<u8>>>;

    /// UserspaceMountOptions property
    #[dbus_proxy(property)]
    fn userspace_mount_options(&self) -> zbus::Result<Vec<String>>;
}

#[dbus_proxy(
    interface = "org.freedesktop.UDisks2.PartitionTable",
    default_service = "org.freedesktop.UDisks2"
)]
trait PartitionTable {
    /// CreatePartition method
    fn create_partition(
        &self,
        offset: u64,
        size: u64,
        type_: &str,
        name: &str,
        options: std::collections::HashMap<&str, zvariant::Value<'_>>,
    ) -> zbus::Result<zvariant::OwnedObjectPath>;

    /// CreatePartitionAndFormat method
    fn create_partition_and_format(
        &self,
        offset: u64,
        size: u64,
        type_: &str,
        name: &str,
        options: std::collections::HashMap<&str, zvariant::Value<'_>>,
        format_type: &str,
        format_options: std::collections::HashMap<&str, zvariant::Value<'_>>,
    ) -> zbus::Result<zvariant::OwnedObjectPath>;

    /// Partitions property
    #[dbus_proxy(property)]
    fn partitions(&self) -> zbus::Result<Vec<zvariant::OwnedObjectPath>>;

    /// Type property
    #[dbus_proxy(property)]
    fn type_(&self) -> zbus::Result<String>;
}

#[dbus_proxy(
    interface = "org.freedesktop.UDisks2.Partition",
    default_service = "org.freedesktop.UDisks2"
)]
trait Partition {
    /// Delete method
    fn delete(
        &self,
        options: std::collections::HashMap<&str, zvariant::Value<'_>>,
    ) -> zbus::Result<()>;

    /// Resize method
    fn resize(
        &self,
        size: u64,
        options: std::collections::HashMap<&str, zvariant::Value<'_>>,
    ) -> zbus::Result<()>;

    /// SetFlags method
    fn set_flags(
        &self,
        flags: u64,
        options: std::collections::HashMap<&str, zvariant::Value<'_>>,
    ) -> zbus::Result<()>;

    /// SetName method
    fn set_name(
        &self,
        name: &str,
        options: std::collections::HashMap<&str, zvariant::Value<'_>>,
    ) -> zbus::Result<()>;

    /// SetType method
    fn set_type(
        &self,
        type_: &str,
        options: std::collections::HashMap<&str, zvariant::Value<'_>>,
    ) -> zbus::Result<()>;

    /// Flags property
    #[dbus_proxy(property)]
    fn flags(&self) -> zbus::Result<u64>;

    /// IsContained property
    #[dbus_proxy(property)]
    fn is_contained(&self) -> zbus::Result<bool>;

    /// IsContainer property
    #[dbus_proxy(property)]
    fn is_container(&self) -> zbus::Result<bool>;

    /// Name property
    #[dbus_proxy(property)]
    fn name(&self) -> zbus::Result<String>;

    /// Number property
    #[dbus_proxy(property)]
    fn number(&self) -> zbus::Result<u32>;

    /// Offset property
    #[dbus_proxy(property)]
    fn offset(&self) -> zbus::Result<u64>;

    /// Size property
    #[dbus_proxy(property)]
    fn size(&self) -> zbus::Result<u64>;

    /// Table property
    #[dbus_proxy(property)]
    fn table(&self) -> zbus::Result<zvariant::OwnedObjectPath>;

    /// Type property
    #[dbus_proxy(property)]
    fn type_(&self) -> zbus::Result<String>;

    /// UUID property
    #[dbus_proxy(property)]
    fn uuid(&self) -> zbus::Result<String>;
}

#[dbus_proxy(
    interface = "org.freedesktop.UDisks2.Filesystem",
    default_service = "org.freedesktop.UDisks2"
)]
trait Filesystem {
    /// Check method
    fn check(
        &self,
        options: std::collections::HashMap<&str, zvariant::Value<'_>>,
    ) -> zbus::Result<bool>;

    /// Mount method
    fn mount(
        &self,
        options: std::collections::HashMap<&str, zvariant::Value<'_>>,
    ) -> zbus::Result<String>;

    /// Repair method
    fn repair(
        &self,
        options: std::collections::HashMap<&str, zvariant::Value<'_>>,
    ) -> zbus::Result<bool>;

    /// Resize method
    fn resize(
        &self,
        size: u64,
        options: std::collections::HashMap<&str, zvariant::Value<'_>>,
    ) -> zbus::Result<()>;

    /// SetLabel method
    fn set_label(
        &self,
        label: &str,
        options: std::collections::HashMap<&str, zvariant::Value<'_>>,
    ) -> zbus::Result<()>;

    /// TakeOwnership method
    fn take_ownership(
        &self,
        options: std::collections::HashMap<&str, zvariant::Value<'_>>,
    ) -> zbus::Result<()>;

    /// Unmount method
    fn unmount(
        &self,
        options: std::collections::HashMap<&str, zvariant::Value<'_>>,
    ) -> zbus::Result<()>;

    /// MountPoints property
    #[dbus_proxy(property)]
    fn mount_points(&self) -> zbus::Result<Vec<Vec<u8>>>;

    /// Size property
    #[dbus_proxy(property)]
    fn size(&self) -> zbus::Result<u64>;
}

#[dbus_proxy(
    interface = "org.freedesktop.UDisks2.Swapspace",
    default_service = "org.freedesktop.UDisks2"
)]
trait Swapspace {
    /// SetLabel method
    fn set_label(
        &self,
        label: &str,
        options: std::collections::HashMap<&str, zvariant::Value<'_>>,
    ) -> zbus::Result<()>;

    /// Start method
    fn start(
        &self,
        options: std::collections::HashMap<&str, zvariant::Value<'_>>,
    ) -> zbus::Result<()>;

    /// Stop method
    fn stop(
        &self,
        options: std::collections::HashMap<&str, zvariant::Value<'_>>,
    ) -> zbus::Result<()>;

    /// Active property
    #[dbus_proxy(property)]
    fn active(&self) -> zbus::Result<bool>;
}

#[dbus_proxy(
    interface = "org.freedesktop.UDisks2.Encrypted",
    default_service = "org.freedesktop.UDisks2"
)]
trait Encrypted {
    /// ChangePassphrase method
    fn change_passphrase(
        &self,
        passphrase: &str,
        new_passphrase: &str,
        options: std::collections::HashMap<&str, zvariant::Value<'_>>,
    ) -> zbus::Result<()>;

    /// Lock method
    fn lock(
        &self,
        options: std::collections::HashMap<&str, zvariant::Value<'_>>,
    ) -> zbus::Result<()>;

    /// Resize method
    fn resize(
        &self,
        size: u64,
        options: std::collections::HashMap<&str, zvariant::Value<'_>>,
    ) -> zbus::Result<()>;

    /// Unlock method
    fn unlock(
        &self,
        passphrase: &str,
        options: std::collections::HashMap<&str, zvariant::Value<'_>>,
    ) -> zbus::Result<zvariant::OwnedObjectPath>;

    /*
    /// ChildConfiguration property
    #[dbus_proxy(property)]
    fn child_configuration(
        &self,
    ) -> zbus::Result<
        Vec<(
            String,
            std::collections::HashMap<String, zvariant::OwnedValue>,
        )>,
    >;
    */

    /// CleartextDevice property
    #[dbus_proxy(property)]
    fn cleartext_device(&self) -> zbus::Result<zvariant::OwnedObjectPath>;

    /// HintEncryptionType property
    #[dbus_proxy(property)]
    fn hint_encryption_type(&self) -> zbus::Result<String>;

    /// MetadataSize property
    #[dbus_proxy(property)]
    fn metadata_size(&self) -> zbus::Result<u64>;
}

#[dbus_proxy(
    interface = "org.freedesktop.UDisks2.Loop",
    default_service = "org.freedesktop.UDisks2"
)]
trait Loop {
    /// Delete method
    fn delete(
        &self,
        options: std::collections::HashMap<&str, zvariant::Value<'_>>,
    ) -> zbus::Result<()>;

    /// SetAutoclear method
    fn set_autoclear(
        &self,
        value: bool,
        options: std::collections::HashMap<&str, zvariant::Value<'_>>,
    ) -> zbus::Result<()>;

    /// Autoclear property
    #[dbus_proxy(property)]
    fn autoclear(&self) -> zbus::Result<bool>;

    /// BackingFile property
    #[dbus_proxy(property)]
    fn backing_file(&self) -> zbus::Result<Vec<u8>>;

    /// SetupByUID property
    #[dbus_proxy(property)]
    fn setup_by_uid(&self) -> zbus::Result<u32>;
}

#[dbus_proxy(
    interface = "org.freedesktop.UDisks2.MDRaid",
    default_service = "org.freedesktop.UDisks2"
)]
trait MDRaid {
    /// AddDevice method
    fn add_device(
        &self,
        device: &zvariant::ObjectPath<'_>,
        options: std::collections::HashMap<&str, zvariant::Value<'_>>,
    ) -> zbus::Result<()>;

    /// Delete method
    fn delete(
        &self,
        options: std::collections::HashMap<&str, zvariant::Value<'_>>,
    ) -> zbus::Result<()>;

    /// RemoveDevice method
    fn remove_device(
        &self,
        device: &zvariant::ObjectPath<'_>,
        options: std::collections::HashMap<&str, zvariant::Value<'_>>,
    ) -> zbus::Result<()>;

    /// RequestSyncAction method
    fn request_sync_action(
        &self,
        sync_action: &str,
        options: std::collections::HashMap<&str, zvariant::Value<'_>>,
    ) -> zbus::Result<()>;

    /// SetBitmapLocation method
    fn set_bitmap_location(
        &self,
        value: &[u8],
        options: std::collections::HashMap<&str, zvariant::Value<'_>>,
    ) -> zbus::Result<()>;

    /// Start method
    fn start(
        &self,
        options: std::collections::HashMap<&str, zvariant::Value<'_>>,
    ) -> zbus::Result<()>;

    /// Stop method
    fn stop(
        &self,
        options: std::collections::HashMap<&str, zvariant::Value<'_>>,
    ) -> zbus::Result<()>;

    /*
    /// ActiveDevices property
    #[dbus_proxy(property)]
    fn active_devices(
        &self,
    ) -> zbus::Result<
        Vec<(
            zvariant::OwnedObjectPath,
            i32,
            Vec<String>,
            u64,
            std::collections::HashMap<String, zvariant::OwnedValue>,
        )>,
    >;
    */

    /// BitmapLocation property
    #[dbus_proxy(property)]
    fn bitmap_location(&self) -> zbus::Result<Vec<u8>>;

    /*
    /// ChildConfiguration property
    #[dbus_proxy(property)]
    fn child_configuration(
        &self,
    ) -> zbus::Result<
        Vec<(
            String,
            std::collections::HashMap<String, zvariant::OwnedValue>,
        )>,
    >;
    */

    /// ChunkSize property
    #[dbus_proxy(property)]
    fn chunk_size(&self) -> zbus::Result<u64>;

    /// Degraded property
    #[dbus_proxy(property)]
    fn degraded(&self) -> zbus::Result<u32>;

    /// Level property
    #[dbus_proxy(property)]
    fn level(&self) -> zbus::Result<String>;

    /// Name property
    #[dbus_proxy(property)]
    fn name(&self) -> zbus::Result<String>;

    /// NumDevices property
    #[dbus_proxy(property)]
    fn num_devices(&self) -> zbus::Result<u32>;

    /// Running property
    #[dbus_proxy(property)]
    fn running(&self) -> zbus::Result<bool>;

    /// Size property
    #[dbus_proxy(property)]
    fn size(&self) -> zbus::Result<u64>;

    /// SyncAction property
    #[dbus_proxy(property)]
    fn sync_action(&self) -> zbus::Result<String>;

    /// SyncCompleted property
    #[dbus_proxy(property)]
    fn sync_completed(&self) -> zbus::Result<f64>;

    /// SyncRate property
    #[dbus_proxy(property)]
    fn sync_rate(&self) -> zbus::Result<u64>;

    /// SyncRemainingTime property
    #[dbus_proxy(property)]
    fn sync_remaining_time(&self) -> zbus::Result<u64>;

    /// UUID property
    #[dbus_proxy(property)]
    fn uuid(&self) -> zbus::Result<String>;
}

#[dbus_proxy(
    interface = "org.freedesktop.UDisks2.Job",
    default_service = "org.freedesktop.UDisks2"
)]
trait Job {
    /// Cancel method
    fn cancel(
        &self,
        options: std::collections::HashMap<&str, zvariant::Value<'_>>,
    ) -> zbus::Result<()>;

    /// Completed signal
    #[dbus_proxy(signal)]
    fn completed(&self, success: bool, message: &str) -> zbus::Result<()>;

    /// Bytes property
    #[dbus_proxy(property)]
    fn bytes(&self) -> zbus::Result<u64>;

    /// Cancelable property
    #[dbus_proxy(property)]
    fn cancelable(&self) -> zbus::Result<bool>;

    /// ExpectedEndTime property
    #[dbus_proxy(property)]
    fn expected_end_time(&self) -> zbus::Result<u64>;

    /// Objects property
    #[dbus_proxy(property)]
    fn objects(&self) -> zbus::Result<Vec<zvariant::OwnedObjectPath>>;

    /// Operation property
    #[dbus_proxy(property)]
    fn operation(&self) -> zbus::Result<String>;

    /// Progress property
    #[dbus_proxy(property)]
    fn progress(&self) -> zbus::Result<f64>;

    /// ProgressValid property
    #[dbus_proxy(property)]
    fn progress_valid(&self) -> zbus::Result<bool>;

    /// Rate property
    #[dbus_proxy(property)]
    fn rate(&self) -> zbus::Result<u64>;

    /// StartTime property
    #[dbus_proxy(property)]
    fn start_time(&self) -> zbus::Result<u64>;

    /// StartedByUID property
    #[dbus_proxy(property)]
    fn started_by_uid(&self) -> zbus::Result<u32>;
}
